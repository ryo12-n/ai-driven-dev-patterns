# git worktree ガイドライン: Claude Code での隔離開発パターン

> **文書の位置づけ**: 本文書は調査・検討結果をまとめたガイドラインであり、現時点では参考情報として扱う。
> CLAUDE.md やルールファイル（`.claude/rules/`）への組み込みは将来の施策で検討する。

> **前提バージョン**: 本文書は 2026年2月時点の Claude Code の仕様に基づく。
> `--worktree` フラグおよび `isolation: "worktree"` 機能の仕様が変更された場合は、本文書を更新すること。

---

## 1. 概要

### git worktree とは

git worktree は、単一の Git リポジトリから複数の作業ディレクトリ（worktree）を作成する Git の標準機能である。各 worktree は独自のブランチとファイルシステムを持ちながら、リポジトリ履歴とリモート接続を共有する。これにより、一方の worktree で行われた変更が他の worktree に影響を与えることなく、並列作業が可能になる。

### Claude Code での worktree サポート

Claude Code は git worktree のネイティブサポートを提供しており、以下の2つのレベルで利用できる。

#### CLI レベル: `--worktree` フラグ

```bash
# 名前を指定して worktree で起動
claude --worktree feature-auth

# 名前を自動生成して起動
claude --worktree

# tmux と組み合わせて起動
claude --worktree feature-auth --tmux
```

- worktree は `<リポジトリ>/.claude/worktrees/<名前>/` に作成される
- ブランチ名は `worktree-<名前>` となる
- デフォルトリモートブランチから分岐する

#### サブエージェントレベル: `isolation: "worktree"`

カスタムサブエージェントの YAML frontmatter に `isolation: worktree` を設定することで、サブエージェントを独立した worktree で実行できる。

```markdown
---
name: content-writer
description: コンテンツを作成する専門エージェント
tools: Read, Write, Bash
isolation: worktree
---

コンテンツの作成を担当します。指定されたディレクトリにファイルを作成してください。
```

サブエージェントが Task ツールで起動されるたびに一時的な worktree が自動作成され、完了時に変更がなければ自動クリーンアップされる。

### worktree のライフサイクル

```
作成 → 作業 → 終了判定 → クリーンアップ

[作成]
  CLI: claude --worktree <名前> で起動時
  サブエージェント: Task ツール呼び出し時に自動

[作業]
  独立したディレクトリ・ブランチで変更を実施
  メインの worktree とは物理的に分離

[終了判定]
  変更なし → worktree とブランチを自動削除
  変更あり → 保持するか削除するかを確認

[クリーンアップ]
  保持: ディレクトリとブランチを維持（後で復帰可能）
  削除: ディレクトリとブランチを削除（変更はすべて破棄）
```

---

## 2. 利用判断基準

### worktree を使うべき場面

| 場面 | 理由 |
|------|------|
| 複数のサブエージェントが並列にファイルを編集する | 物理的な隔離により、同一ファイルへの同時書き込みによる競合を防止 |
| 独立性の高いタスクを並列実行する | 各タスクが独自のブランチで作業でき、変更を個別にレビュー可能 |
| 実験的な変更を安全に試したい | メインブランチに影響を与えずに変更を試行し、不要なら破棄できる |
| バッチ的なコード変更（例: 50ファイルのAPI移行） | 複数エージェントにファイルを分割して並列処理 |

### worktree を使わないべき場面

| 場面 | 理由 |
|------|------|
| 読み取り専用の調査・分析タスク | Explore や Plan サブエージェントは隔離不要。オーバーヘッドが不当 |
| 単一エージェントでの逐次作業 | 並列化の恩恵がなく、worktree 作成のオーバーヘッドのみ発生 |
| 大規模モノレポでの軽微な変更 | worktree 作成と環境セットアップのコストが変更のメリットを上回る |
| タスク間に強い依存関係がある | 並列実行できず、順次実行のほうが効率的 |
| 現在の L1/L2 ワークフロー（順次実行） | 現状は worker → evaluator の順次起動で競合が発生しない設計 |

### 判断フローチャート

```
[タスクの性質を確認]
  │
  ├── 読み取り専用か？ ── Yes → worktree 不要
  │
  ├── 複数エージェントが並列にファイルを編集するか？
  │     │
  │     ├── Yes → worktree 推奨
  │     │
  │     └── No ── 単一エージェントか？ ── Yes → worktree 不要
  │
  ├── リポジトリサイズは？
  │     │
  │     ├── 大規模モノレポ → 環境セットアップコストを考慮して判断
  │     │
  │     └── 小〜中規模 → worktree のオーバーヘッドは軽微
  │
  └── タスク間の依存関係は？
        │
        ├── 強い依存あり → 順次実行（worktree 不要）
        │
        └── 独立している → worktree で並列化を検討
```

---

## 3. ロックベース方式との比較

### 参考 PoC のロックベース方式

`refs/ai-driven-development-poc/` で採用されているロックベース方式は、テキストファイル（`.lock`）を Git リポジトリ上で管理し、タスクの排他制御を実現するアプローチである。Anthropic 社の [Building a C Compiler](https://www.anthropic.com/engineering/building-c-compiler) 記事で紹介された並列 Claude 活用手法を汎用化したものに基づく。

### 比較表

| 比較軸 | ロックベース方式 | worktree 方式 |
|--------|----------------|--------------|
| **隔離レベル** | 論理的（ルールによる排他制御） | 物理的（別ディレクトリ・別ブランチ） |
| **ファイル競合** | プロトコル違反時に発生しうる | 構造的に発生しない（マージ時に検出） |
| **競合の検出タイミング** | push 時にリアルタイム検出 | マージ時に事後検出 |
| **環境コスト** | 低い（単一ディレクトリ） | 高い（worktree ごとに環境セットアップ） |
| **可視性** | `locks/` ディレクトリで作業状況が一目瞭然 | `git worktree list` で確認可能 |
| **プロトコル複雑さ** | ロック取得・解放・コンフリクト解消のルールが必要 | git worktree + ブランチマージの標準フローで管理 |
| **適するアーキテクチャ** | 外部プロセス並列（tmux）、独立した Claude CLI セッション | Claude Code のサブエージェント機能（Task ツール） |
| **障害復旧** | 長時間ロックの手動解除が必要 | worktree の手動削除で対応可能 |
| **マージ方式** | 同一ブランチに直接 push | ブランチ間マージ |
| **スケーラビリティ** | エージェント数に比例してロック競合リスク増加 | エージェント数に比例してディスク使用量増加 |
| **Claude Code 統合** | 自作プロトコルが必要 | `isolation: worktree` で宣言的に設定可能 |

### 方式選択の指針

**worktree 方式が適するケース:**
- Claude Code のサブエージェント機能（Task ツール）を使用する場合
- 同じファイルを複数エージェントが編集する可能性がある場合
- コンフリクトの事後解決が許容される場合
- `isolation: worktree` による宣言的な設定で運用を簡素化したい場合

**ロックベース方式が適するケース:**
- 外部プロセス（tmux 並列、シェルスクリプト起動）でのエージェント並列実行
- タスク間のファイル依存が明確に分離されている場合
- リアルタイムの排他制御が必要な場合（同じファイルへの同時書き込みを完全に防ぎたい場合）
- 大規模リポジトリで worktree の環境セットアップコストが高い場合

**両方式は排他的ではなく補完的である。** worktree で物理的に隔離した上で、共有リソース（外部データベース、共有設定ファイル等）のアクセスにロックを使うこともできる。

---

## 4. 現在の L1/L2 ワークフローとの関係

### 現在のワークフロー構造

```
[L1 マネージャー]
  フェーズ0: 壁打ち → 提案 → 計画 → タスク作成
                                          ↓
[L2 ワーカー（実施）] ← L1 が Task ツールで順次起動
  壁打ち → タスク実施 → 作業記録 → レポート作成
                                          ↓
  L1: worker 成果物確認 → 品質判断
                                          ↓
[L2 ワーカー（評価）] ← L1 が worker 完了後に順次起動
  壁打ち → 評価計画 → 評価実施 → 評価レポート
                                          ↓
[L1 マネージャー]
  ゲート判定 → 次フェーズ or 差し戻し
```

### worktree 導入時の影響分析

#### 現状で worktree が不要な理由

1. **順次実行モデル**: L2-worker → L2-evaluator の順番で起動されるため、ファイル競合が発生しない
2. **ファイル所有権ルール**: L1/L2 の担当ファイルが分離されており、同一ファイルへの同時書き込みがない
3. **文書中心の作業**: コード変更を伴わないため、環境セットアップのオーバーヘッドが不当

#### 将来の並列化で影響を受ける箇所

| # | 影響箇所 | 変更の内容 | 影響度 |
|---|---------|-----------|-------|
| 1 | L1 のサブエージェント起動方式 | `isolation: worktree` の指定追加 | 高 |
| 2 | 作業ログ（`03_work_log.md`）の構造 | 複数 worker 並列時のマージ戦略（ファイル分割 or 追記プロトコル） | 高 |
| 3 | 課題メモ（`07_issues.md`）の構造 | 複数 worker/evaluator 並列時の書き込み競合回避 | 中 |
| 4 | タスクリスト（`02_tasks.md`）のステータス更新 | 複数 worker による同時チェックボックス更新の競合回避 | 中 |
| 5 | L1 の成果物確認フロー | 複数 worktree からのマージ後に成果物を確認するフロー追加 | 中 |
| 6 | `.gitignore` の更新 | `.claude/worktrees/` の追加 | 低 |

#### 現時点での推奨

**現在の L1/L2 ワークフローでは worktree の導入は不要。** 順次実行モデルとファイル所有権ルールにより、既にファイル競合が防止されている。worktree の導入は、L2-worker の並列化を実施する際に検討すべきである。

---

## 5. 将来の拡張方針

### 段階的な導入ロードマップ

#### ステージ 1: 現状維持（順次実行）
- 現在の L1 → L2-worker → L2-evaluator の順次起動を維持
- worktree は導入しない
- このステージでの成果物: 本ガイドラインの作成（完了）

#### ステージ 2: 独立タスクの並列化（worktree 活用）
- 複数の L2-worker を worktree で隔離して並列起動
- 適用条件: タスク間に依存関係がなく、担当ファイルが明確に分離されている場合
- 必要な準備:
  - 作業ログのファイル構造見直し（worker ごとの個別ログファイル）
  - マージ戦略の定義
  - L1 のオーケストレーションロジック更新

#### ステージ 3: 高度な並列化（worktree + 協調プロトコル）
- 共有リソースへのアクセスが必要なタスクも並列化
- worktree による物理隔離 + ロック/コミットプロトコルによる論理的調整の組み合わせ
- 必要な準備:
  - 協調プロトコル施策（`initiatives/coordination-protocol/`）の成果物の統合
  - コンフリクト自動解決ツールの検討
  - テスト戦略（並列環境でのテスト実行順序・範囲）の定義

### 並列 L2 への適用見通し

**短期（ステージ 2 適用可能な場面）:**
- 調査タスクの並列化（複数の技術調査を同時に実行）
- 独立したドキュメント作成の並列化
- 評価ワーカーの並列化（複数の評価観点を同時に評価）

**中長期（ステージ 3 が必要な場面）:**
- コード変更を伴うタスクの並列化
- 同一施策内の複数フェーズの一部並列化
- クロス施策のタスク並列実行

---

## 6. 協調プロトコル施策との接続点

### 関連施策

`initiatives/coordination-protocol/` では、以下の3つのプロトコルの定義が予定されている:

1. **commit プロトコル**: コミットタイミング・メッセージ規約・コンフリクト解消手順
2. **lock プロトコル**: 排他制御の仕組み・対象リソースの粒度・デッドロック回避策
3. **test プロトコル**: テスト実行の順序・範囲・失敗時の振る舞い

### worktree との接続点

| プロトコル | worktree との関係 |
|-----------|------------------|
| **commit** | worktree 上ではブランチが分離されるため、同一ブランチへの push コンフリクトは発生しない。ただし、マージ時のコミット戦略（squash / merge commit / rebase）の定義が必要 |
| **lock** | worktree によりファイルレベルの排他制御は不要になる。ただし、共有リソース（外部サービス、設定ファイル等）のアクセスにはロックが必要な場合がある |
| **test** | 各 worktree で独立にテストを実行可能。ただし、テスト結果の集約方法と、テスト失敗時の他エージェントへの影響範囲の定義が必要 |

### 本ガイドラインとの関係

- 本ガイドラインは **インフラ層（物理的隔離メカニズム）** を扱う
- 協調プロトコル施策は **アプリケーション層（隔離された環境上での運用ルール）** を扱う
- 協調プロトコル施策は本ガイドラインの成果を前提条件として取り込む設計になっている（`00_proposal.md` に明記済み）

### 参考 PoC からの知見の活用

`refs/ai-driven-development-poc/` の以下のプロトコル設計は、協調プロトコル施策での分析・カスタマイズの対象となる:

- `lock_protocol.md`: タスクロックの取得・解放手順
- `commit_protocol.md`: コミットメッセージ規約、push 前の手順
- `test_protocol.md`: 2段階テスト（高速チェック + フルテスト）

---

## 7. 制約・注意事項

### 技術的な制約

1. **パフォーマンスオーバーヘッド**: 各 worktree はリポジトリの完全なファイルシステムコピーを作成する。大規模リポジトリでは作成に時間がかかり、ディスク容量を消費する

2. **環境セットアップの必要性**: 新しい worktree ごとに開発環境の初期化が必要。プロジェクトのスタックに応じて以下が必要になる:
   - パッケージインストール（`npm install`、`pip install` 等）
   - 仮想環境の構築
   - 設定ファイルのコピー（`.env` 等）

3. **サブエージェントのネスト不可**: サブエージェントは他のサブエージェントを起動できない。ネストされた委任が必要な場合はスキルまたはメイン会話からのチェーンを使用する

4. **非 git VCS の追加設定**: SVN、Perforce、Mercurial 等を使用する場合は `WorktreeCreate` と `WorktreeRemove` フックの設定が別途必要

### 運用上の注意事項

1. **`.gitignore` への追加**: `.claude/worktrees/` を `.gitignore` に追加し、worktree の内容がメインリポジトリの未追跡ファイルとして表示されるのを防ぐ

2. **worktree の手動管理**: Claude Code 外で worktree を管理する場合は `git worktree add` / `git worktree remove` を使用する。セッション外でのクリーンアップには手動操作が必要

3. **ファイルパスの監査**: worktree 導入時は各エージェントが触れるファイルパスを監査し、コンフリクトの可能性を事前に特定すること

4. **マージコンフリクトの事後対応**: worktree 方式では競合はマージ時まで検出されない。コンフリクト解決の手順を事前に定義しておくこと

5. **書き込み並列化でのみ使用**: 読み取り専用のサブエージェント（Explore、Plan）には `isolation: worktree` を設定しない。オーバーヘッドが不当

### 本ガイドラインの適用範囲

- 本文書はガイドライン（参考情報）であり、CLAUDE.md やルールファイルへの組み込みは行っていない
- 実際の導入時には本文書を基に具体的なルール・プロトコルを策定する必要がある
- Claude Code の仕様変更に追従して本文書を更新する運用が必要

---

**作成者**: L2（実施）
**作成日**: 2026-02-25
**関連施策**: `initiatives/git-worktree-standardization/`
**参照資料**:
- [Claude Code 公式ドキュメント - Common workflows](https://code.claude.com/docs/en/common-workflows)
- [Claude Code 公式ドキュメント - Create custom subagents](https://code.claude.com/docs/en/sub-agents)
- `refs/ai-driven-development-poc/` (ロックベース並列開発フレームワーク)
- `initiatives/coordination-protocol/00_proposal.md` (協調プロトコル施策)
