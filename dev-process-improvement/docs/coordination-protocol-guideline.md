# 協調プロトコルガイドライン: commit / lock / test

> **文書の位置づけ**: 本文書は調査・検討結果をまとめたガイドラインであり、現時点では参考情報として扱う。
> CLAUDE.md やルールファイル（`.claude/rules/`）への組み込みは将来の施策で検討する。

> **前提**: 本文書は `docs/git-worktree-guideline.md`（git worktree 施策の成果物）を前提条件として取り込んでいる。
> worktree ガイドラインは「インフラ層（物理的隔離メカニズム）」を、本文書は「アプリケーション層（隔離された環境上での運用ルール）」を扱う。

---

## 1. 概要

### 本ガイドラインの目的

複数の Claude エージェント（L1 マネージャー、L2-worker、L2-evaluator）が並列に動作する場面において、以下の3つの協調プロトコルを定義する。

1. **commit プロトコル**: コミットタイミング・メッセージ規約・ブランチ戦略・コンフリクト解消手順
2. **lock プロトコル**: 排他制御の仕組み・対象リソースの粒度・デッドロック回避策
3. **test プロトコル**: テスト実行の順序・範囲・失敗時の振る舞い

### 適用範囲

- 本リポジトリ（`dev-process-improvement/`）における L1/L2 ワークフロー
- 現在の運用（順次実行）と将来の運用（並列実行）の両方に対応

### 設計の前提

- 本施策は**予防的な検討**であり、現時点で具体的な競合問題は発生していない
- 成果物は**ガイドライン文書**であり、ルールファイルへの組み込みやスクリプト実装は将来の施策で行う
- 参考 PoC（`refs/ai-driven-development-poc/`）の設計を分析し、本リポジトリの運用に適した形にカスタマイズしている

### 参考 PoC の設計分析サマリー

`refs/ai-driven-development-poc/` は、Anthropic 社の「Building a C Compiler」記事で紹介された並列 Claude 活用手法を汎用化したフレームワークである。以下の3つのプロトコルが定義されている。

| プロトコル | 設計思想 | 本リポジトリへの適用 |
|-----------|---------|-------------------|
| **lock_protocol.md** | テキストファイルベースの楽観的ロック。Git push の成功/失敗でロック取得を判定 | 概念を採用しつつ、ロック対象をタスク単位からファイル/リソース単位に変更 |
| **commit_protocol.md** | `[role-id]` プレフィックスによるエージェント識別。全員同一ブランチで rebase 運用 | L1/L2 ロール体系に合わせたメッセージ規約に変更。worktree 利用時はブランチ分離 |
| **test_protocol.md** | 2段階テスト（fast/full）。コミット前に fast、push 前に full を必須実行 | 概念を採用しつつ、文書中心リポジトリ向けにテスト内容を再定義 |

---

## 2. commit プロトコル

### 2.1 コミットタイミング

| シナリオ | タイミング | 備考 |
|---------|-----------|------|
| L2-worker（順次実行） | タスク完了時に一括コミット | 現在の運用に合致 |
| L2-worker（並列実行） | 論理的な作業単位ごとにコミット | 変更を小さく保ち、マージコンフリクトのリスクを低減 |
| L2-evaluator | 評価レポート完成時にコミット | 評価は読み取り中心のため、コミット頻度は低い |
| L1 | 計画・タスク作成完了時にコミット | 計画フェーズに集中 |

**原則**: 小さく、頻繁にコミットする。大きな変更を1つのコミットにまとめることは避ける。

### 2.2 コミットメッセージ規約

参考 PoC の `[role-id] category-task_id: summary` を本リポジトリの L1/L2 体系に適応した形式を定義する。

**形式:**

```
[<session-type>] <initiative>: <summary>

<details>
```

**パラメータ:**

| パラメータ | 説明 | 例 |
|-----------|------|-----|
| `session-type` | セッション種別 | `L1` / `L2-worker` / `L2-evaluator` |
| `initiative` | 施策名（initiatives/ 配下のディレクトリ名） | `coordination-protocol` |
| `summary` | 1行の要約（50文字以内推奨） | `ガイドライン文書を作成` |
| `details` | 変更したファイル一覧、作業内容の詳細（任意） | 複数行の説明 |

**例:**

```
[L2-worker] coordination-protocol: ガイドライン文書を作成

- docs/coordination-protocol-guideline.md を新規作成
- 03_work_log.md に作業履歴を記録
- 04_work_report.md に作業レポートを作成
```

**禁止事項:**
- `git push --force` の使用
- 意味のないコミットメッセージ（`update`, `fix`, `wip` 等のみ）
- セッション種別のないコミットメッセージ

### 2.3 ブランチ戦略

| シナリオ | ブランチ戦略 | マージ方式 |
|---------|-------------|-----------|
| 順次実行（現状） | 施策ごとのフィーチャーブランチ（`claude/<施策名>-<suffix>`）で作業し main へマージ | 通常のマージコミット |
| worktree 並列実行（将来） | 各 worktree にエージェント個別ブランチ（`worktree-<名前>`）を自動作成 | squash merge を推奨（並列作業の中間コミットをクリーンにまとめる） |

### 2.4 コンフリクト解消手順

#### 順次実行時（現状）

ファイル所有権ルールにより同時編集がないため、コンフリクトは原則発生しない。発生した場合は以下の手順で対応する。

1. `git pull --rebase` でリモートの変更を取得
2. コンフリクト箇所を確認し、手動で解消
3. テストを実行して整合性を確認
4. コミット・push

#### 並列実行時（worktree、将来）

1. マージ時にコンフリクトが検出された場合、L1 がコンフリクト内容を確認
2. ファイル所有権に基づき、各エージェントの変更を尊重して解消
3. 解消後にフルテストを実行して整合性を確認
4. 解消の判断が困難な場合は、関係するエージェントの worktree を一時停止し、L1 が調整

**PoC 由来の原則**: 同一リソースへの同時変更は「後から来たエージェントが引き下がる」。ロックベースの排他制御を使用している場合、push コンフリクト = ロック取得失敗であり、別タスクへ移行する。

### 2.5 worktree 利用時と非利用時の差異

| 項目 | 非 worktree（順次実行） | worktree（並列実行） |
|------|----------------------|---------------------|
| ブランチ | 共有フィーチャーブランチ | エージェント個別ブランチ |
| push コンフリクト | 発生しうる（同一ブランチ） | 発生しない（ブランチ分離） |
| マージコンフリクト | なし（順次実行） | マージ時に検出 |
| コミット粒度 | タスク完了時一括 | 小さな論理単位ごと推奨 |
| マージ方式 | 通常のマージコミット | squash merge 推奨 |

---

## 3. lock プロトコル

### 3.1 排他制御の対象

| 対象 | 具体例 | 排他制御の方式 |
|------|--------|--------------|
| 施策ファイル（L1 所有） | `00_proposal.md`, `01_plan.md`, `02_tasks.md`, `08_gate_review.md` | ファイル所有権ルール（暗黙的排他） |
| 施策ファイル（L2-worker 所有） | `03_work_log.md`, `04_work_report.md` | ファイル所有権ルール（暗黙的排他） |
| 施策ファイル（L2-evaluator 所有） | `05_eval_plan.md`, `06_eval_report.md` | ファイル所有権ルール（暗黙的排他） |
| 共有ファイル | `07_issues.md`, `プロセス改善_課題管理.csv` | 並列実行時は明示的ロックが必要 |
| docs/ 配下の成果物 | ガイドライン文書等 | 並列で同一文書を編集する場合はロックが必要 |

### 3.2 ロック方式

段階的な3層のロック方式を定義する。下位の層から順に適用し、必要に応じて上位の層を追加する。

| 層 | 方式 | 適用シナリオ | 追加実装 |
|----|------|-------------|---------|
| **層1: ファイル所有権（暗黙的ロック）** | L1/L2 のファイル所有権ルール | 現在の順次実行 | 不要（既存ルール） |
| **層2: worktree による物理的隔離** | `isolation: worktree` でブランチ・ディレクトリを分離 | 将来の並列実行（独立タスク） | worktree の設定のみ |
| **層3: テキストファイルベースの明示的ロック** | 共有リソースのみに適用 | 将来の並列実行（共有リソースアクセス時） | ロックスクリプトの実装 |

#### 層3 のロックファイル仕様

参考 PoC のテキストファイルベースロックを簡略化して採用する。

**ファイル配置:**

```
.locks/<resource-name>.lock
```

**ファイル内容:**

```
agent: <session-type>-<identifier>
started: <ISO 8601 形式の日時>
resource: <対象リソースのパス>
```

**例:**

```
.locks/07_issues.lock

agent: L2-worker-A
started: 2026-02-25T10:30:00+09:00
resource: initiatives/coordination-protocol/07_issues.md
```

**ロック取得手順:**
1. 対象リソースのロックファイルが存在しないことを確認
2. ロックファイルを作成
3. `git add` + `git commit` + `git push`
4. push 成功 = ロック取得完了

**ロック解放手順:**
1. 対象リソースへの操作完了
2. ロックファイルを削除
3. `git add` + `git commit` + `git push`

### 3.3 ロックの粒度とデッドロック回避策

**粒度**: ファイル単位。1ファイル = 1ロック。PoC のタスク単位ロックからファイル単位に変更し、より細粒度の制御を可能にする。

**デッドロック回避策:**

| 対策 | 内容 |
|------|------|
| ロック取得順序の固定 | 複数ファイルをロックする場合、ファイルパスの辞書順で取得する |
| タイムアウト | ロック取得の試行は30秒でタイムアウト |
| 同時ロック数の制限 | 1エージェントが同時に保持できるロック数は最大3 |
| 長時間ロック検出 | 30分超のロックは自動警告、1時間超は人間が介入 |

### 3.4 ロック取得失敗時の振る舞い

| 状況 | 振る舞い |
|------|---------|
| ロック取得失敗（他エージェントが保持中） | 即座に別タスクへ移行（「引き下がる」原則） |
| ロック取得失敗（タイムアウト） | `07_issues.md` にブロック状況を起票し、L1 に判断を委ねる |
| ロック保持中にエラー発生 | ロックを解放してからエラー報告 |
| エージェント異常停止 | 人間が検出して手動解放 |

### 3.5 L1/L2 ファイル所有権との関係

現在の L1/L2 ファイル所有権ルール（層1）は**変更せずそのまま維持**する。

- 並列実行が導入されるまでは層1のみで十分（追加のロック機構は不要）
- 並列実行導入時に層2（worktree）を優先適用し、層3（明示的ロック）は共有リソースのみに限定
- 層1 → 層2 → 層3 の順で段階的に適用し、運用の複雑さを最小限に抑える

---

## 4. test プロトコル

### 4.1 テスト実行タイミング

| タイミング | テスト種別 | 必須/推奨 | 備考 |
|-----------|-----------|---------|------|
| コミット前 | Fast Check（高速チェック） | 推奨 | テストスクリプトが整備されていない場合はスキップ可 |
| push / マージリクエスト前 | Full Test（フルテスト） | 推奨 | CI が整備されている場合は必須化を検討 |
| worktree マージ前 | Full Test | 必須（並列実行時） | マージ後の整合性を保証 |

### 4.2 テスト範囲

本リポジトリは文書中心であるため、テスト内容をコードリポジトリ向けの PoC から再定義する。

| テスト種別 | 内容 | 実行時間目安 |
|-----------|------|------------|
| **Fast Check** | YAML/Markdown の構文チェック、リンク切れ検出、ファイル命名規則チェック | 30秒以内 |
| **Full Test** | 上記 + ドキュメント間の整合性チェック（参照先の存在確認等）、テンプレート準拠チェック | 2分以内 |

**参考 PoC との対比:**

| 項目 | 参考 PoC（コード中心） | 本リポジトリ（文書中心） |
|------|---------------------|----------------------|
| Fast Check | lint + type check + critical テスト | YAML/Markdown 構文 + リンク切れ |
| Full Test | 全ユニットテスト + 統合テスト + カバレッジ | 整合性チェック + テンプレート準拠 |
| 制限時間（fast） | 30秒 | 30秒 |
| 制限時間（full） | 5分 | 2分 |

### 4.3 並列テスト実行時の排他制御

| シナリオ | 排他の要否 | 方針 |
|---------|-----------|------|
| 各 worktree で独立にテスト実行 | 不要 | 各 worktree が独立したファイルシステムを持つため、テスト間の干渉なし |
| 共有テスト環境がある場合 | 必要 | テスト用の環境変数やポートを worktree ごとに分離するか、ロックを使用 |
| マージ後のフルテスト | 不要 | マージは L1 が制御するため、逐次実行 |

### 4.4 テスト失敗時の振る舞い

| 失敗の種類 | 対応 |
|-----------|------|
| 自エージェントの変更が原因 | 修正してテストを再実行。修正できない場合は変更をリバートし、`07_issues.md` に起票 |
| 他エージェントの変更が原因（マージ後に検出） | L1 に報告し、コンフリクト解消の判断を委ねる |
| 既存のテスト不備 | `07_issues.md` にテスト不備として起票し、現在のタスクは続行 |
| テスト環境の問題 | リトライ。解消しない場合は `07_issues.md` に起票 |

**他エージェントへの通知:**

| シナリオ | 通知方法 |
|---------|---------|
| 順次実行（現状） | 他エージェントが存在しないため通知不要 |
| 並列実行（将来） | テスト失敗が共有リソースに影響する場合のみ、L1 経由で通知 |

### 4.5 2段階テストの採用可否

**採用する（段階的に導入）。**

| ステージ | Fast Check の内容 | Full Test の内容 |
|---------|------------------|-----------------|
| ステージ1（現状） | 未整備（スキップ可） | 未整備（スキップ可） |
| ステージ2（テスト整備後） | YAML 構文チェック、Markdown lint | + リンク切れ検出、テンプレート準拠チェック |
| ステージ3（並列実行時） | 上記 + 変更ファイル関連の整合性チェック | + 全ファイルの整合性チェック、クロスリファレンス検証 |

---

## 5. 各プロトコルの相互関係

### 5.1 プロトコル間の依存関係

```
[lock プロトコル]
  ロック取得
    ↓
[commit プロトコル]
  ファイル編集 → テスト実行 → コミット → push
    ↓                ↑
[test プロトコル]     │
  テスト実行 ─────────┘
    ↓
[lock プロトコル]
  ロック解放
```

### 5.2 プロトコル間の連携ルール

| 連携 | ルール |
|------|--------|
| lock → commit | ロックを取得してからファイルを編集し、コミットする。ロック解放はコミット後に行う |
| commit → test | コミット前に Fast Check を実行する。push 前に Full Test を実行する |
| test → lock | テスト失敗時はロックを解放してから 07_issues.md に起票する |
| lock → test | ロック保持中にテストを実行する場合、ロックのタイムアウトに注意する |

### 5.3 典型的なワークフロー

#### 順次実行時（現状）

```
1. L2-worker がタスクを受領
2. ファイルを編集（ファイル所有権ルールにより排他制御済み）
3. [推奨] Fast Check を実行
4. コミット（[L2-worker] initiative: summary 形式）
5. [推奨] Full Test を実行
6. push
```

#### 並列実行時（将来）

```
1. L2-worker-A が worktree で個別ブランチを作成
2. 共有リソースが必要な場合はロックを取得
3. ファイルを編集
4. Fast Check を実行
5. コミット（小さな論理単位ごと）
6. ロックを解放（共有リソースの場合）
7. Full Test を実行
8. push
9. L1 がマージ時にコンフリクトを確認・解消
10. マージ後にフルテストを実行
```

---

## 6. 適用シナリオ

### 6.1 シナリオ1: 順次実行（現在の運用）

**構成**: L1 → L2-worker → L2-evaluator の順次起動

**適用するプロトコル:**
- commit プロトコル: コミットメッセージ規約のみ適用
- lock プロトコル: 層1（ファイル所有権）のみ。追加のロック機構は不要
- test プロトコル: テストスクリプトが整備されている場合のみ適用

**特記事項:**
- 現在の L1/L2 ワークフローでは、ファイル所有権ルールにより暗黙的な排他制御が成立している
- 順次実行のため、コンフリクトやデッドロックのリスクはない
- コミットメッセージ規約の導入から始めることを推奨

### 6.2 シナリオ2: 独立タスクの並列実行（将来のステージ2）

**構成**: L1 → 複数の L2-worker を worktree で並列起動

**適用するプロトコル:**
- commit プロトコル: 全項目を適用（個別ブランチ + squash merge）
- lock プロトコル: 層1 + 層2（worktree）。共有リソースがなければ層3 は不要
- test プロトコル: 各 worktree で独立テスト + マージ前フルテスト

**前提条件:**
- タスク間に依存関係がないこと
- 担当ファイルが明確に分離されていること
- `docs/git-worktree-guideline.md` のステージ2 準備が完了していること

### 6.3 シナリオ3: 共有リソースを含む並列実行（将来のステージ3）

**構成**: 複数の L2-worker が worktree で並列実行し、一部の共有リソースにアクセスする

**適用するプロトコル:**
- commit プロトコル: 全項目を適用
- lock プロトコル: 層1 + 層2 + 層3（共有リソースに明示的ロック）
- test プロトコル: 全項目を適用（並列テスト排他制御を含む）

**追加の準備:**
- 層3 のロックスクリプト実装
- 共有リソースの一覧定義
- テスト実行スクリプト（`ci/run_fast.sh`, `ci/run_full.sh`）の整備

---

## 7. git worktree ガイドラインとの関係

### 7.1 レイヤー分離

| レイヤー | 担当ガイドライン | 内容 |
|---------|----------------|------|
| インフラ層 | `docs/git-worktree-guideline.md` | 物理的隔離メカニズム（worktree の作成・管理・クリーンアップ） |
| アプリケーション層 | 本文書 | 隔離された環境上での運用ルール（commit/lock/test プロトコル） |

### 7.2 接続点の詳細

| プロトコル | worktree との関係 | 設計への反映 |
|-----------|------------------|-------------|
| **commit** | worktree 上ではブランチが分離されるため、同一ブランチへの push コンフリクトは発生しない | マージ戦略（squash merge 推奨）を commit プロトコルに定義 |
| **lock** | worktree によりファイルレベルの排他制御は不要になる | lock プロトコルの層2 として worktree を位置づけ。層3 は共有リソースのみに限定 |
| **test** | 各 worktree で独立にテストを実行可能 | マージ前フルテストを test プロトコルに定義 |

### 7.3 段階的導入ロードマップとの整合

worktree ガイドラインのステージ定義と本ガイドラインの対応:

| worktree ステージ | 本ガイドラインの適用範囲 |
|------------------|----------------------|
| ステージ1（現状維持・順次実行） | コミットメッセージ規約 + ファイル所有権ルール（層1） |
| ステージ2（独立タスクの並列化） | 全 commit プロトコル + worktree 隔離（層2）+ 独立テスト |
| ステージ3（高度な並列化） | 全プロトコル（層1〜3 + 2段階テスト + コンフリクト解消手順） |

---

## 8. 段階的導入の方針

### 8.1 導入ステップ

本ガイドラインは一度に全て導入するのではなく、以下のステップで段階的に適用する。

#### ステップ1: コミットメッセージ規約の導入（即時適用可能）

- `[session-type] initiative: summary` 形式のコミットメッセージを L1/L2 セッションで使用開始
- 既存のワークフローへの影響は最小限（コミットメッセージの形式変更のみ）
- 将来のエージェント識別・進捗追跡の基盤になる

#### ステップ2: テストスクリプトの整備（ステージ2 準備）

- `ci/run_fast.sh`（YAML 構文チェック、Markdown lint）を実装
- `ci/run_full.sh`（整合性チェック、テンプレート準拠チェック）を実装
- コミット前の Fast Check 実行を推奨ルールとして導入

#### ステップ3: worktree 並列化の準備（ステージ2 移行時）

- L1 のサブエージェント起動方式に `isolation: worktree` を追加
- 作業ログのファイル構造見直し（worker ごとの個別ログファイル）
- マージ戦略の運用確認

#### ステップ4: 明示的ロックの導入（ステージ3 移行時）

- 共有リソースの一覧を定義
- `.locks/` ディレクトリとロックスクリプトを実装
- デッドロック回避策の運用確認

### 8.2 導入時の注意事項

- 各ステップは独立しており、前のステップが完了してから次に進む
- ステップ1 は現在の運用で即時適用可能だが、ルールファイルへの組み込みは別施策で行う
- 導入後は実運用でのフィードバックを収集し、プロトコルを改善する
- プロトコルが過剰に複雑にならないよう、最小限のルールから始めて段階的に拡張する

### 8.3 将来の検討事項

| 項目 | 内容 | 検討時期 |
|------|------|---------|
| ルールファイルへの組み込み | 本ガイドラインの内容を `.claude/rules/` に反映 | ステージ2 移行時 |
| ロックスクリプトの実装 | `.locks/` の管理スクリプト | ステージ3 移行時 |
| CI パイプラインの整備 | GitHub Actions でのテスト自動実行 | テストスクリプト整備後 |
| post-commit フックの導入 | コミット時の自動チェック・進捗記録 | テストスクリプト整備後 |
| Agent Teams 機能との統合 | Claude Code の Agent Teams 機能（実験的）利用時のプロトコル適応 | Agent Teams 機能の安定化後 |

---

**作成者**: L2（実施）
**作成日**: 2026-02-25
**関連施策**: `initiatives/coordination-protocol/`
**参照資料**:
- `refs/ai-driven-development-poc/` (並列 Claude 開発フレームワーク)
- `docs/git-worktree-guideline.md` (git worktree ガイドライン)
- `initiatives/coordination-protocol/00_proposal.md` (本施策の提案書)
